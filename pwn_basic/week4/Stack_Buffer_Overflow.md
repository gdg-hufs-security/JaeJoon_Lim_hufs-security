#  함수 호출 규약
  - **함수 호출 및 반환에 대한 약속**이다.

  - 호출자의 상태 및 반환 주소
    - 한 함수에서 다른 함수를 호출할 때 프로그램 실행 흐름은 다른 함수로 이동한다. 그리고 호출한 함수가 반환하면, 다시 원래의 함수로 돌아와서 기존 실행 흐름을 이어나간다. 이때 필요한 것들이 **호출자의 상태 및 반환 주소**이다.
   
  - 호출자와 피호출자의 역할
    - 호출자 : 피호출자가 요구하는 인자를 전달해줘야 함.
    - 피호출자 : 반환 값을 전달해줘야 함.

  - 누가 함수 호출 규약을 적용하는가?
    - **컴파일러**
      - 프로그래머가 고수준 언어로 코드를 작성하면, 컴파일러가 호출 규약에 맞게 코드를 컴파일한다.
        - 컴파일러가 아키텍처에 맞게 호출 규약을 적용해주니 사용자가 딱히 몰라도 된다.
        - 컴파일러는 지원하는 호출 규약 중, CPU아키텍처에 적합한 것을 선택한다.
        - CPU의 아키텍처가 같아도 컴파일러에 따라 다른 호출 규약을 적용할 수도 있다.
          
  - 우리가 함수 호출 규약을 배워야하는 이유
    - 컴파일러 도움없이 어셈블리 코드를 작성해야 하는 경우
    - 어셈블리로 작성된 코드를 읽고자 하는 경우
    - 이 두 경우에 함수 호출 규약을 알아야 한다.
   


# 함수 호출 규약의 종류
  - x86
    - **cdecl**
    - stdcall
    - fastcall
    - thiscall

  - x86-64
    - **System V AMD64 ABI의 Calling Convention**
    - MS ABI의 Calling Convention
   


#x86-64 호출 규약: SYSV
  - 리눅스는 SYSTEM V(SYSV) Application Binary Interface(ABI)를 기반으로 만들어졌다.
    - 리눅스에서 실행되는 수많은 프로그램들은 서로 다른 개발자들에 의해 만들어진다. 프로그램마다 파일 형식, 함수 호출 방법, 데이터를 주고 받는 규칙이 제각각이면 운영체제는 이 프로그램들을 제대로 실행할 수 없다. 그래서 SYSV라는 표준 규칙을 만들어 모든 프로그램이 이 규칙을 따르도록 약속한 것이다.
   
  - 그렇다면 어떤 규칙들이 있을까?
    - 파일 형식 (ELF)
      - 모든 실행 파일은 ELF 형식으로 저장된다. 운영체제는 이 형식을 알고 있으니 파일을 읽고 실행할 수 있다.
    - 함수 호출 규칙
      - 프로그램이 함수를 호출할 때 어떤 값이 레지스터에 들어가는지 정해져 있다. 이 부분은 예전에 셀 코드를 작성할 때 경험해봤다.
      - 예를 들어, 첫 번째 인자는 RDI 레지스터, 두 번째 인자는 RSI 레지스터에 넣는 식이다.
    - 링킹
      - 링킹이란?) 여러 개의 코드 조각을 하나의 **실행 파일**로 합치는 과정이다.
      - (이 부분은 공부를 해봐야겠다.)

  - 우분투에서  file /bin/ls 명령어를 입력했을 때, SYSV문자열이 포함된 것을 볼 수 있다.
    ```
    root@노트북:~# file /bin/ls
    /bin/ls: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=36b86f957a1be53733633d184c3a3354f3fc7b12, for GNU/Linux 3.2.0, stripped
    ```

  - SYSV에서 정의한 함수 호출 규약의 특징
    - 6개의 인자를 RDI, RSI, RDX, RCX, R8, R9에 순서대로 저장하여 전달합니다. 더 많은 인자를 사용해야 할 때는 스택을 추가로 이용합니다.
    - Caller에서 인자 전달에 사용된 스택을 정리합니다.
      - 함수 호출 시 7번째 인자부터 스택에 정리된다. 스택에 저장된 인자는 함수가 끝난 후에도 메모리에 남아 있습니다. 만약 Caller가 이를 정리하지 않으면 메모리 누수, 이후 함수 호출 시 스택이 잘못된 위치에 있을 수 있다.
    - 함수의 반환 값은 RAX로 전달합니다.
   
  - 
