# pwntools
  1) 해커들이 익스플로로잇을 하기 위해 만든 파이썬 모듈.
  2) 여러 함수들이 있다.
  3) 사용 방법은 다음과 같다.
     ```
     from pwn import *
     ```
  4) 일반적으로 사용되는 VS code 환경이 아닌 리눅스 환경에서 사용한다.


# pwntools 함수 종류
  1) process
     - 익스플로잇을 로컬 바이너리를 대상으로 할 때 사용하는 함수이다.
       - 내 컴퓨터(로컬 컴퓨터)에서 실행 중인 프로그램에 먼저 테스트할 때 사용한다.
       - 원격 서버에서 테스트하기 전에 로컬에서 문제를 재현하고 디버깅하는 용도로 많이 사용된다.
       - **리허설**이라고 보면 된다.
     - 보통 익스플로잇을 테스트하고 디버깅하기 위해 사용한다.

  2) remote
     - 원격 서버를 대상으로 할 때 사용하는 함수이다.
       - 인터넷에 있는 서버와 연결해서 대화를 할 수 있게 해주는 함수이다.
       - 전체적인 흐름은 process를 사용해 내 컴퓨터로 한 번 실험한 뒤 remote 함수로 상대를 공격하는 과정이다.
     - 예시
       ```
        from pwn import *
        p = process('./test')  # 로컬 바이너리 'test'를 대상으로 익스플로잇 수행
        p = remote('example.com', 31337)  # 'example.com'의 31337 포트에서 실행 중인 프로세스를 대상으로 익스플로잇 수행
       ```
        - 바이너리란?) 컴파일된 실행 파일  예시) .exe   .elf 등
        - ./test 에서 ./는 **현재 디렉토리**를 나타내고, test는 **내 컴퓨터에 있는 파일**이다.
        - example.com 은 외부 서버이다. 내 컴퓨터가 아닌 다른 사람의 서버이다.
        - **포트**는 서버와 통신할 때 사용하는 통로이다. 서버는 하나의 IP주소를 가질 수 있지만, 여러 개의 포트를 통해 다양한 프로그램과 연결될 수 있다. **(쉽게 말해 포트는 서버의 여러 대화 채널 중 하나이다.**)
      
  3) send
     - 데이터를 프로세스에 전송하기 위해 사용한다.
     - 예시
       ```
        from pwn import *
        p = process('./test')
        
        p.send(b'A')  # ./test에 b'A'를 입력
        p.sendline(b'A') # ./test에 b'A' + b'\n'을 입력
        p.sendafter(b'hello', b'A')  # ./test가 b'hello'를 출력하면, b'A'를 입력
        p.sendlineafter(b'hello', b'A')  # ./test가 b'hello'를 출력하면, b'A' + b'\n'을 입력
       ```
         - send관련 함수는 여러 가지가 있으며 **줄바꿈, 조건 대기** 등이 추가 된다.

  4) recv
     - 프로세스에서 데이터를 받기 위해 사용한다.
     - recv() 와 recvn() 차이점
       - recv() : 최대 n바이트를 받는다. 그만큼을 받지 못해도 에러를 발생시키지 않는다.
       - recvn() : 정확히 n바이트의 데이터를 받지 못하면 계속 기다린다.
     - 예시
       ```
        from pwn import *
        p = process('./test')
        
        data = p.recv(1024)  # p가 출력하는 데이터를 최대 1024바이트까지 받아서 data에 저장
        data = p.recvline()  # p가 출력하는 데이터를 개행문자를 만날 때까지 받아서 data에 저장
        data = p.recvn(5)  # p가 출력하는 데이터를 5바이트만 받아서 data에 저장
        data = p.recvuntil(b'hello')  # p가 b'hello'를 출력할 때까지 데이터를 수신하여 data에 저장
        data = p.recvall()  # p가 출력하는 데이터를 프로세스가 종료될 때까지 받아서 data에 저장
       ```
         - 종류에 따라 얼마나 받을지, 정확히 받을지 고를 수 있다.

  5) packing & unpacking
     - 어떤 값을 리틀 엔디언의 바이트 배열로 변경하거나, 그 역의 과정을 거칠 때 사용한다.
       - 리블 엔디언이란?)
         - 데이터를 저장하거나 전송할 때, **가장 낮은 바이트를 가장 먼저 저장하는 방식**이다.
         - 빅 엔디언 방식은 **큰 바이트부터** 차례대로 저장한다.
     - 정수 -> 리틀 엔디안 바이트 배열 : p32()
       리틀 엔디안 바이트 배열 : u32()

  6) interactive()
     - 프로그램과 직접 상호작용할 수 있는 모드로 전환해주는 함수이다.
     - 언제 사용할까?
       - 셸을 획득한 후
         - 익스플로잇이 성공해서 셸에 접속했을 때, 셸에서 명령어를 직접 입력하고 결과를 볼 수 있다.
       - 수동 입력이 필요할 때
         - 익스플로잇 중에 직접 데이터를 입력하거나, 출력을 확인하면서 다음 입력을 결정할 때 사용한다.
     - 예시
       ```
        from pwn import *
        p = process('./test')
        p.interactive()
       ```
        
  7) ELF
     - ELF 헤더에 있는 각종 정보를 볼 수 있는 함수이다.
     - 예시
       ```
        from pwn import *
        e = ELF('./test')
        puts_plt = e.plt['puts'] # ./test에서 puts()의 PLT주소를 찾아서 puts_plt에 저장
        read_got = e.got['read'] # ./test에서 read()의 GOT주소를 찾아서 read_got에 저장
       ```

  8) context.log
     - 익스플로잇을 디버깅하는 함수이다.

  9) context.arch
      - ???
    
  10) shellcraft
      - 셸코드를 쉽게 생성할 수 있도록 도와주는 모듈이다.
      - 한계
        - 자주 사용되는 셸 코드들이 저장되어 있지만, 정적으로 생성된 셸 코드는 실행될 때의 메모리 상태를 반영하지 못한다.
        - 프로그램에 따라 입력할 수 있는 셸 코드의 길이나, 구성 가능한 문자의 종류에 제한이 있을 수 있는데, 이런 조건들도 반영하기 어렵다.
          
  11) asm
      - 어셈블리 코드를 기계어로 변환하는 기능을 제공한다. 어셈블리 명령어를 실행 가능한 바이너리 코드로 쉽게 변환할 수 있다.
      - shellcraft를 사용해 어셈블리 셸코드를 생성하고 asm함수를 사용해 기계어로 변환한다.
  
