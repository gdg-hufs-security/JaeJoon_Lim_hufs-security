# GDB란?
  - 프로그램 실행을 제어하고 분석할 수 있는 디버깅 도구.
  - 주로 C언어, C++언어 프로그램의 디버깅에 사용된다.


# pwndbg는?
  - GDB의 확장 프로그램이라고 보면 된다. 즉, GDB 플러그인이다. 익스플로잇 개발, 리버스 엔지니어링, 보안 취약점 분석 등에 유용하다.


# 우분투와 GDB의 관계?
  - 우분투는 리눅스 기반 운영 체제이다. gdb를 실행하기 위한 환경이라고 보면 된다.


# Windows 보다 우분투?
  - 보안 및 익스플로잇 개발, 리버스 엔지니어링과 같은 보안 연구에서는 Windows의 CMD보다 우분투의 GDB를 사용하는 것이 더 일반적이다.
    >>> 왜?) cmd에 비해 gdb에서 디버깅과 보안 분석에 용이하다. 자세한 건 추후에 알아보자.


[실습]
# gdb에서 pwndbg 사용
  - 컴파일한 C언어 실행 파일을 gdb에서 디버깅해보자.
  - pwndbg로 실행하면 보기 좋게 context가 4개 영역으로 나뉜다.
    > REGISTERS : 레지스터의 상태를 보여준다.
    > DISASM : rip부터 여러 줄에 걸쳐 디스어셈블된 결과를 보여준다.                     // rip이란?) CPU 레지스터로, 현재 진행 중인 명령어의 메모리 주소를 가리킨다. 항상 다음에 실행할 명령어 주소를 가리킨다. 
    > STACK : rsp부터 여러 줄에 걸쳐 스택의 값들을 보여준다.                            // rsp이란?) 스택의 최상단을 가리키는 레지스터.
    > BACKTRACE : 현재 rip에 도달할 떄까지 어떤 함수들이 중첩되어 호출됐는지 보여준다.


# break / continue
  - 무슨 기능인가?) 우리는 보통 프로그램의 일부를 확인한다. 이떄, break로 중단점을 설정해 그곳에서 프로그램이 멈추도록 하는 기능. continue는 해당 부분을 확인한 뒤 다시 프로그램을 재개하는 기능이다.
  - 언제 사용할까?) 프로그램의 실행 흐름을 추적하고 특정 코드 위치에서 상태를 분석하고 싶을 때 break 명령을 사용하여 중단점을 설정한다. 그 다음, 중단점에 도달했을 때 디버깅으로 변수상태, 메모리 상태 등을 확인 후 continue로 다음 중단점 ro 프로그램 종료 시점까지 계속한다.
  
  - 사용법)
    > break main   -> main 함수 시작 부분에 중단점      // main 함수는 무엇인가?) 프로그램의 실행이 시작되는 곳이다. 프로그램의 주요 로직이 들어간다. 운영 체제는 프로그램이 실행될 때, main 함수를 호출하여 프로그램의 실행을 시작한다.  {아직 잘 모르겠다}
    > break debugee1.c:15  -> 컴파일된 debugee1이란 파일의 15번째 줄에 중단점
    > break *0x401050   -> 특정 메모리 주소에 중단점
    > c or continue   -> 다음 중단점 or 프로그램의 끝까지 실행

  - 실제 코드 사용해보기)
    > 우선 pwndbg 활성화 상태에서  b* main을 쳐보자
    > Break point 1 at 0x1149 라는 출력값이 나왔다.
      => 무엇을 의미할까?) 0x1149라는 지점에 첫 번째 중단점이 생겼다는 말이다.


# disassembly
  - 무엇인가?) 기계어에서 어셈블리어로 사람이 보기 편하게 변환하는 과정이다.
  - gdb에서 기본적으로 제공하는 디스어셈블 : disassemble main
    pwndbg에서 제공하는 디스어셈블 : u , nearpc   (훨씬 가독성이 있다.)


# navigate
  - 무엇인가?) break으로 중단점에 도달했을 때, 명령어를 한 줄씩 분석할 때 사용하는 명령어
  - ni 와 si가 있다.
    > ni (next instrucion) : 서브루틴을 호출했을 때 서브루틴의 내부로 들어가지 않는다.    // 서브루틴?) 함수, 매서드 따위라고 보면 된다.
    > si (step into) : 서브루틴을 호출했을 때 내부로 들어간다.

  - 로드맵 예시로 학습하자)
    > b *main+64 로 printf 함수에 중단점을 설정한다
    > ni를 입력하면 printf 함수 다음으로 rip가 이동한 것을 확인할 수 있다.
      => 함수의 외부 흐름만 살펴보고 싶을 때 ni를 사용한다.
    > si을 입력하면 printf 함수 내부로 들어가서 내부 명령어를 한 줄씩 실행한다.
      => 함수의 내부 동작을 살펴보고 싶을 때 si를 사용한다.

# finish
  - si로 함수 내부를 모두 분석하고 함수의 규모가 너무 커서 ni로는 원래 실행 흐름으로 가기 어려울 때 사용. (이 말 이해 잘 안 됨)
  - 즉, 함수의 끝으로 가고 싶을 때 사용한다.

# examine  명령어 x
  - 이 명령어를 사용하면 특정 주소에서 원하는 길이 만큼의 데이터를 원하는 형식으로 인코딩하여 볼 수 있다.
  - 프로그램을 분석하다 보면 가상 메모리에 존재하는 임의 주소의 값을 관찰해야 할 때가 있는데 이때 사용하면 된다.
  - 사용 예시)
    > x/10gx $rsp    의미: rsp부터 80바이트를 8바이트씩 hex형식(16진수)으로 출력하라
      => x : 명령어 x
      => /10 : 10개 항목을 표시
      => g : 8바이트 단위이다.  2g는 16바이트를 의미.
      => x : 16진수(hex)형식으로 출력하라는 의미.
      => $rsp : 현재 스택포인터(rsp)가 카리키는 주소에서 시작하라는 의미.

# telescope   명령어 tele
  - 강력한 메모리 덤프 기능.
  - 메모리가 참조하고 있는 주소를 재귀적으로 탐색하여 값을 보여준다.

# vmmap     명령어 vmmap
  - 가상 메모리의 레이아웃을 보여준다.
